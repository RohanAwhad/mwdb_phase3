# -*- coding: utf-8 -*-
"""515Pro3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cDpKAnb6xN9z85wqpRpB4p3xbD7s24Um
"""

# Imports
import torch
import torchvision.models as models
import torchvision
from torchvision import datasets
import pandas as pd
import numpy as np
import os
resnet50 = models.resnet50(pretrained=True) # Load pre-trained ResNet-50 model
data_dir = './caltech101_data' # Define the data directory where you want to save the dataset
caltech_dataset = datasets.Caltech101(data_dir, download=True) # Download and extract the dataset

from torchvision import transforms

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])


def extract_features(image):
    image = image.convert('RGB')
    image = preprocess(image)
    image = image.unsqueeze(0)
    with torch.no_grad():
        features = resnet50(image)
    return features.cpu().numpy().flatten()

even_images = [img for i, img in enumerate(caltech_dataset) if i % 2 == 0]

features_list = []
for img, _ in even_images:
    features = extract_features(img)
    features_list.append(features.flatten())

def pca(data, variance_threshold=0.95):
    # Standardize data
    data = (data - np.mean(data, axis=0)) / np.std(data, axis=0)

    # Covariance matrix
    covariance_matrix = np.cov(data, rowvar=False)

    # Eigenvalues and eigenvectors
    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)

    # Sort by eigenvalue in descending order
    sorted_index = np.argsort(eigenvalues)[::-1]
    sorted_eigenvalues = eigenvalues[sorted_index]
    sorted_eigenvectors = eigenvectors[:,sorted_index]

    # Compute cumulative variance
    cumulative_variance = np.cumsum(sorted_eigenvalues) / np.sum(sorted_eigenvalues)

    # Determine how many principal components to use
    num_components = np.where(cumulative_variance >= variance_threshold)[0][0] + 1

    return num_components

# Apply custom PCA
features_matrix = np.array(features_list)
inherent_dimensionality = pca(features_matrix)

# Print inherent dimensionality
print("Inherent Dimensionality:", inherent_dimensionality)